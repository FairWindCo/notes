<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>

# Terraform
Це інструмент, що дозволяє зробити опис інфраструктури, а потім привести вказану інфрастурктуру у стан, що був заданий описом.
Важливим моментом, варто зазаначити, що терраформ працює лише в одному напрямку, тобто неможливо вже існуючи конфігурацію перетворити в опис.
Це важливо в тому випадку, що якщо ви внесете зміни вручну і потім застосуєте конфігурацію то ваші зміни будуть знищені.

Сам Terraform являє собою фактично один єдиний бінарний файл написаний на ГО, а також окремо сам терраформ може скачати провайдери для конкретних хмарних платформ, що теж являють собою бінарні файли (проте достатньо виликих ромірів).
Конфігурація описується в текстовому файлі (заведено давати файлам розширення tf).

Сам тераформ можна звантажити за посиланням: https://developer.hashicorp.com/terraform/install
Сам тераформ має вилику кількість провайерів для работи з хмарними інфраструктурами.
Встановлення досить просте завантажити архів та разпакувати, потім або дадати змінну PATH що б вона вказувала на каталог де лежить файл, або покласти файл в такий каталог яка вже є в PATH


## <g>Конфігурації</g>
Напочатку файл конфігурації єде опис необхдних провайдерів, що відповідають за те на яких платформах буде створюватися інфраструктура.
Наприклад для підключення провайдера для aws, необхідно на початок додати такий код:
```
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "5.81.0"
    }
  }
}
```
Тепер, для того, щоб працювати з платформою необхідно встановити необхідного провайдера, для цього виконують команду:
`terraform init`

Для того, щоб підключатися до платформи необхіно вказати дані для аутентіфікації, це робиться таким чином:
```
provider "aws" {
access_key = "KEY"
secret_key = "SECRET"
region     = "REGION"
}
```
Вказуються дані для створеного користувача, а також регіон де виконується сервіси.
Потім йде опис секрвісів, що повинні створитися:
```
resource "aws_instance" "test_machine" {
  ami = "ami-03250b0e01c28d196"
  instance_type = "t3.micro"
```
Це опис створює віртуальну машину з назвою test_machine, для ОС використовуєтсья ami-03250b0e01c28d196 (що відповідає за Убунту, їх перелік можна дізнатися зі сторінки де в консолі админістратора створюється новий інстанс)
Крім того, використовується шаблон ресурсів: t3.micro.

## Застосування конфігурації
Розлянено дві наступні команди:
- `terraform plan`
- `terraform apply`

Перша показує, що саме збирається зробити тераформ, спочатку він з1єдається з платформою дізнається що там на справді є потім порівняє зі збереженим станом (що зберігається в файлі з розширенням tfstate) а потім з конфігурацією і якщо він виявить розбіжності то сформує план їх усунення.
Друга команда безпосередньо застосовує зміни (і хоча перша команда не є необхідною для важливих конфігурацій краще спершу застосовувати її та перевіряти ті дії які будуть виконані).
<r>Важливо після виконання apply буде створено tfstate (формат JSON) в якому зеберуться всі параметри того, що було створено, а головне їх ідентифікатори. Якщо цей файл видалити, то тераформ буде вважати, що нічього не створено і буде створювати все заново, а керування тім що було буде встрачено.</r>
При виконанні apply, тераформ перевіряє наявність tfstate, якщо він є - то буде йти порівняння з тим, що вже є, якщо файла немає, то просто йде створення нових ресурсів.

Для того, щоб змінити конфіграцію треба внести в файл необхідні зміни та застосувати її. (якщо з файлу щосу було видално, то воно видалеться і з хмари, те саме зі змінами та додаванням.)
Варто зазаначити, що часто зміна це не редагування на літу, в кращому випадку відбудеться запинення ресурсу, його зміна, а потім запуск, що займе певний час. Проте в деяких випадках буде не зміна ресурсу а його видалення та створення нового, що варто враховувати.

Для видалення всього якщо конфігурація необхідна:
`terraform destroy`
видалить повністю всі ресурси що є в стані. Наприклад для цілей провести роботу, а потім її зупинити.

Не варто зберігати ключи безпосередньо в конфігурації, краще, наприклад прописувати їх як змінні сесії:
```
export AWS_ACCESS_KEY_ID=<id>
export AWS_SECRET_ACCESS_KEY=<secret>
```

