# Коли БД розростається треба його стискати

У PostgreSQL ОНОВЛЕННЯ або ВИДАЛЕННЯ рядка не відразу видаляє стару версію рядка. Цей підхід необхідний для отримання переваг багатоверсійного керування паралелізмом: версію рядка не можна видаляти, поки вона все ще потенційно видима для інших транзакцій. Але згодом застаріла або видалена версія рядка більше не представляє інтересу для жодної транзакції. Потім простір, який він займає, має бути звільнений для повторного використання новими рядками, щоб уникнути необмеженого зростання вимог до дискового простору. Це робиться за допомогою запуску VACUUM.

Стандартна форма VACUUM видаляє мертві версії рядків у таблицях та індексах і позначає простір, доступний для повторного використання в майбутньому. Однак це не поверне простір операційній системі, за винятком особливого випадку, коли одна або кілька сторінок у кінці таблиці стають повністю вільними, і можна легко отримати ексклюзивне блокування таблиці. Навпаки, VACUUM FULL активно ущільнює таблиці, записуючи повністю нову версію файлу таблиці без мертвого простору. Це мінімізує розмір столу, але може зайняти багато часу. Також потрібен додатковий дисковий простір для нової копії таблиці до завершення операції.

Хоча за допомогою VACUUM FULL можна зменшити таблицю до її мінімального розміру та повернути дисковий простір операційній системі, у цьому немає особливого сенсу, якщо в майбутньому таблиця знову збільшиться. Таким чином, помірно часті стандартні прогони VACUUM є кращим підходом, ніж нечасті прогони VACUUM FULL для підтримки сильно оновлених таблиць.
Складність із очищенням за фіксованим графіком полягає в тому, що якщо таблиця має несподіваний сплеск активності оновлення, вона може стати роздутою до такої міри, що VACUUM FULL дійсно необхідний для відновлення місця. Використання демона автоматичного вакуумування усуває цю проблему, оскільки демон динамічно планує очищення у відповідь на оновлення. Нерозумно повністю вимикати демон, якщо у вас немає надзвичайно передбачуваного робочого навантаження. Одним із можливих компромісів є встановлення параметрів демона таким чином, щоб він реагував лише на надзвичайно інтенсивну активність оновлення, таким чином утримуючи речі від виходу з-під контролю, тоді як очікується, що заплановані VACUUMs виконають основну частину роботи, коли навантаження типове.
Проте варто пам'ятати, що FULL автоматично не виконується.

Для тих, хто не використовує автоматичний демон, типовий підхід полягає в тому, щоб запланувати VACUUM для всієї бази даних один раз на день протягом періоду низького використання, доповнений більш частим стисканням сильно оновлених таблиць, якщо необхідно. (Деякі інсталяції з надзвичайно високою швидкістю оновлення стискають свої найзавантаженіші таблиці так часто, як один раз на кілька хвилин.) Якщо у вас є кілька баз даних у кластері, не забудьте стискати кожну; програма vacuumdb може бути корисною.
Порада: простий VACUUM може бути незадовільним, якщо таблиця містить велику кількість версій мертвих рядків у результаті масового оновлення або видалення. Якщо у вас є така таблиця, і вам потрібно звільнити надлишковий дисковий простір, який вона займає, вам потрібно буде використовувати VACUUM FULL, або альтернативно CLUSTER або один із варіантів перезапису таблиці ALTER TABLE. Ці команди переписують повністю нову копію таблиці та створюють для неї нові індекси. Усі ці параметри вимагають ексклюзивного блокування. Зауважте, що вони також тимчасово використовують додатковий дисковий простір, який приблизно дорівнює розміру таблиці, оскільки старі копії таблиці та індексів не можуть бути звільнені, доки нові не будуть завершені.

Порада: якщо у вас є таблиця, весь вміст якої періодично видаляється, подумайте про те, щоб зробити це за допомогою TRUNCATE, а не за допомогою DELETE з подальшим VACUUM. TRUNCATE негайно видаляє весь вміст таблиці, не вимагаючи наступного VACUUM або VACUUM FULL, щоб відновити невикористаний дисковий простір.
[посилання на документацію](https://www.postgresql.org/docs/9.5/routine-vacuuming.html)

Планувальник запитів PostgreSQL покладається на статистичну інформацію про вміст таблиць, щоб створити хороші плани для запитів. 
Цю статистику збирає команда ANALYZE, яку можна викликати окремо або як додатковий крок у VACUUM. Важливо мати досить точну статистику, інакше неправильний вибір планів може погіршити продуктивність бази даних.

Демон автовакууму, якщо його ввімкнено, автоматично видаватиме команди ANALYZE щоразу, коли вміст таблиці істотно зміниться. Однак адміністратори можуть віддати перевагу покладатись на заплановані вручну операції ANALYZE, особливо якщо відомо, що оновлення таблиці не вплине на статистику «цікавих» стовпців. Демон планує ANALYZE суворо залежно від кількості вставлених або оновлених рядків; він не знає, чи призведе це до значущих статистичних змін.

## синтаксис VACUUM
```
VACUUM [ ( { FULL | FREEZE | VERBOSE | ANALYZE } [, ...] ) ] [ table_name [ (column_name [, ...] ) ] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table_name ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ table_name [ (column_name [, ...] ) ] ]
```
Якщо список параметрів узятий у дужки, параметри можна записати в будь-якому порядку. Без дужок параметри мають бути вказані саме в порядку, зазначеному вище.

Звичайний VACUUM (без FULL) просто звільняє простір і робить його доступним для повторного використання. Ця форма команди може працювати паралельно зі звичайним читанням і записом таблиці, оскільки ексклюзивне блокування не отримується. Однак додаткове місце не повертається операційній системі (у більшості випадків); він просто зберігається доступним для повторного використання в одній таблиці. VACUUM FULL перезаписує весь вміст таблиці в новий дисковий файл без додаткового місця, дозволяючи повернути невикористаний простір до операційної системи. Ця форма набагато повільніша і вимагає ексклюзивного блокування кожної таблиці під час її обробки.
- FULL - Робить «повне» стискання, який може звільнити більше місця, але займає набагато більше часу та виключно блокує таблицю. Цей метод також вимагає додаткового дискового простору, оскільки він записує нову копію таблиці та не звільняє стару копію, доки операція не буде завершена. Зазвичай це слід використовувати лише тоді, коли потрібно звільнити значну кількість простору всередині таблиці.
- FREEZE - Вибирає агресивне «заморожування» кортежів. Вказівка FREEZE еквівалентна виконанню VACUUM з параметрами vacuum_freeze_min_age і vacuum_freeze_table_age, встановленими на нуль. Агресивне заморожування завжди виконується під час перезапису таблиці, тому цей параметр зайвий, якщо вказано FULL.
- VERBOSE - Друкує докладний звіт про роботу вакууму для кожного столу.
- ANALYZE - Оновлює статистику, яку використовує планувальник для визначення найефективнішого способу виконання запиту.

Без параметра VACUUM обробляє кожну таблицю в поточній базі даних, яку поточний користувач має дозвіл на очищення. За допомогою параметра VACUUM обробляє лише цю таблицю.

VACUUM ANALYZE виконує VACUUM, а потім ANALYZE для кожної вибраної таблиці. Це зручна комбінована форма для сценаріїв планового обслуговування. Щоб отримати докладніші відомості про його обробку, перегляньте ANALYZE.

VACUUM потребує що користувач який його запустив, бути власником таблиці або суперкористувачем. Проте власникам баз даних дозволено очищати всі таблиці у своїх базах даних, окрім спільних каталогів. (Обмеження для спільних каталогів означає, що справжній VACUUM для всієї бази даних може виконувати лише суперкористувач.) VACUUM пропускатиме будь-які таблиці, для яких користувач, що викликає, не має дозволу на очищення.
VACUUM не можна виконати всередині блоку транзакції.
[Детально](https://www.postgresql.org/docs/9.5/sql-vacuum.html)


TRUNCATE швидко видаляє всі рядки з набору таблиць. Він має такий самий ефект, як некваліфіковане DELETE для кожної таблиці, але оскільки він фактично не сканує таблиці, це швидше. Крім того, він миттєво звільняє дисковий простір, а не вимагає подальшої операції VACUUM. Це найбільш корисно на великих столах.

```
TRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ] [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
```
- RESTART IDENTITY - Автоматично перезапускати послідовності, що належать стовпцям усіченої таблиці (таблиць).
- CONTINUE IDENTITY - Не змінюйте значення послідовностей. Це значення за умовчанням.
- CASCADE  - Автоматично скорочувати всі таблиці, які мають посилання зовнішнього ключа на будь-яку з іменованих таблиць або на будь-які таблиці, додані до групи через CASCADE.
- RESTRICT - Відмовтеся від скорочення, якщо будь-яка з таблиць має посилання на зовнішній ключ із таблиць, яких немає в списку в команді. Це значення за умовчанням.
Ви повинні мати привілей TRUNCATE для таблиці, щоб її скоротити.

TRUNCATE не можна використовувати для таблиці, яка має посилання на зовнішні ключі з інших таблиць, якщо всі такі таблиці також не скорочуються в одній команді. Перевірка дійсності в таких випадках потребуватиме сканування таблиці, і вся суть його не робити. Опцію CASCADE можна використовувати для автоматичного включення всіх залежних таблиць, але будьте дуже обережні, використовуючи цю опцію, інакше ви можете втратити дані, яких не збиралися!

TRUNCATE не запускатиме тригери ON DELETE, які можуть існувати для таблиць. Але він запускатиметься НА тригерах TRUNCATE. Якщо для будь-якої таблиці визначено тригери ON TRUNCATE, то всі тригери BEFORE TRUNCATE запускаються до будь-якого усікання, а всі тригери AFTER TRUNCATE запускаються після виконання останнього усічення та скидання будь-яких послідовностей. Тригери запускатимуться в тому порядку, у якому мають бути оброблені таблиці (спочатку таблиці, перелічені в команді, а потім усі, додані через каскад).

TRUNCATE не безпечний для MVCC. Після скорочення таблиця відображатиметься порожньою для одночасних транзакцій, якщо вони використовують знімок, зроблений до того, як сталося скорочення.
[документація](https://www.postgresql.org/docs/9.5/sql-truncate.html)


# Налаштування WAL
Існує кілька конфігураційних параметрів, що стосуються WAL, які впливають на продуктивність СУБД. Далі розповідається про їхнє використання. Докладніше про встановлення параметрів конфігурації сервера див. у Розділі 18.
Контрольні точки — це точки в послідовності транзакцій, в яких гарантується, що файли з даними та індексами були оновлені всією інформацією, записаною перед контрольною точкою. Під час контрольної точки, всі «брудні» сторінки даних, що знаходяться в пам'яті, зберігаються на диск, а файл журналу записується спеціальний запис контрольної точки. (Зроблені зміни були перед цим записані у файли WAL.) У разі краху процедура відновлення шукає останній запис контрольної точки, щоб визначити цю точку в журналі (називається записом REDO), від якої процедура має розпочати операцію відтворення змін. Будь-які зміни файлів даних перед цією точкою гарантовано знаходяться на диску. Таким чином, після контрольної точки сегменти журналу, які передують запису відтворення, більше не потрібні і можуть бути видалені або пущені в циклічний перезапис. (Коли архівування WAL буде завершено, сегменти журналу повинні бути архівовані перед видаленням або циклічним перезаписом.)
Запис усіх «брудних» сторінок даних з пам'яті на диск, який потрібний для контрольної точки, може спричинити значне навантаження на дискове введення/виведення. З цієї причини активність запису по контрольній точці регулюється так, що введення/виведення починається при старті контрольної точки і завершується перед стартом наступної контрольної точки; це мінімізує втрату продуктивності під час проходження контрольних точок.

Окремий серверний процес контрольних точок автоматично виконує контрольні точки із заданою частотою. Контрольні точки проводяться кожні checkpoint_timeout секунд або при наближенні до межі max_wal_size, якщо це відбувається раніше. Значення за замовчуванням: 5 хвилин та 1 Гбайт відповідно. Якщо нові записи WAL не додалися після попередньої контрольної точки, наступні контрольні точки будуть пропущені, навіть якщо проходить час checkpoint_timeout. (Якщо ви використовуєте архівацію WAL і хочете встановити нижню межу для частоти архівації, щоб обмежити потенційну втрату даних, вам слід налаштовувати параметр archive_timeout, а не параметри контрольних точок.) Також можна виконати контрольну точку примусово, скориставшись командою SQL CHECKPOINT.
Зменшення значень checkpoint_timeout та/або max_wal_size призводить до почастішання контрольних точок. Це дозволяє прискорити відновлення після краху (оскільки для відтворення потрібно менше даних), але з іншого боку потрібно враховувати додаткове навантаження, що виникає внаслідок частішого скидання «брудних» сторінок даних на диск. Якщо включено режим full_page_writes (за замовчуванням це так), потрібно врахувати ще один фактор. Для забезпечення цілісності сторінки даних при першій зміні сторінки даних після контрольної точки ця сторінка записується в журнал повністю. У цьому випадку чим менше інтервал між контрольними точками, тим більше обсяг запису в журнал WAL, так що це частково дискредитує ідею зменшення інтервалу запису, і в будь-якому випадку призводить до збільшення обсягу обміну з диском.

Контрольні точки досить дорогі з погляду ресурсів, по-перше, тому що вони вимагають запису всіх «брудних» буферів з пам'яті на диск, і по-друге, тому що вони створюють додатковий трафік WAL, про що йшлося вище. Таким чином, буде розумним встановити параметри контрольних точок так, щоб контрольні точки не виконувались надто часто. Для простої перевірки параметрів контрольної точки можна встановити checkpoint_warning. Якщо проміжок часу між контрольними точками буде меншим за кількість секунд, задане параметром checkpoint_warning, то журнал сервера буде видано повідомлення з рекомендацією збільшити max_wal_size. Епізодична поява такого повідомлення не є приводом для занепокоєння. Але якщо воно з'являється часто, необхідно збільшити параметри керування контрольними точками. Масові операції, такі як COPY з великим обсягом даних, можуть призвести до появи кількох таких попереджень, якщо ви не встановили max_wal_size досить великим.
Щоб уникнути «завалювання» системи введення/виводу при різкому інтенсивному записі сторінок, запис «брудних» буферів під час контрольної точки розтягується на певний період. Цей період керується параметром checkpoint_completion_target, який визначається як частина інтервалу контрольної точки. Швидкість введення/виводу підлаштовується так, щоб контрольна точка завершилася до моменту закінчення заданої частини від checkpoint_timeout секунд або до перевищення max_wal_size, якщо вона має місце раніше. Зі значенням 0.5, заданим за умовчанням, можна очікувати, що Postgres Pro завершить процедуру контрольної точки приблизно за половину часу до початку наступної. У системі, яка працює практично на межі потужності вводу/виводу у звичайному режимі, є сенс збільшити checkpoint_completion_target, щоб зменшити навантаження вводу/виводу, пов'язане з контрольними точками. Але з іншого боку, розтягування контрольних точок впливає на час відновлення, оскільки для відновлення потрібно буде задіяти більше сегментів WAL. Хоча в checkpoint_completion_target можна задати значення аж до 1.0, краще вибрати значення менше (принаймні не більше 0.9), так як при контрольних точках виконуються і деякі інші операції, крім запису «брудних» буферів. Зі значенням 1.0 контрольні точки, швидше за все, не завершуватимуться вчасно, що призведе до втрати продуктивності через несподівані коливання необхідної кількості сегментів WAL.

На платформах Linux та POSIX параметр checkpoint_flush_after дозволяє змусити ОС до скидання сторінок, що записуються під час контрольної точки, при накопиченні заданої кількості байт. Якщо його не налаштувати, ці сторінки можуть залишатися в кеші сторінок ОС, що спричинить загальмовування під час виконання fsync в кінці контрольної точки. Цей параметр часто допомагає зменшити затримки транзакцій, але може й негативно вплинути на продуктивність; особливо коли обсяг навантаження більше shared_buffers, але менше кешу сторінок в ОС.

Число файлів сегментів WAL у каталозі pg_xlog залежить від min_wal_size, max_wal_size та обсягу WAL, згенерованого в попередніх циклах контрольних точок. Коли старі файли сегментів не потрібні, вони видаляються або переробляються (тобто перейменовуються, щоб стати майбутніми сегментами в нумерованій послідовності). Якщо внаслідок короткочасного стрибка інтенсивності запису в журнал, межа max_wal_size перевищується, непотрібні файли сегментів будуть видалятися, доки система не опуститься нижче цієї межі. Залишаючись нижче цієї межі, система переробляє стільки файлів WAL, скільки необхідно покриття очікуваної потреби до наступної контрольної точки, і видаляє інші. Ця оцінка базується на ковзному середній кількості файлів WAL, задіяних у попередніх циклах контрольних точок. Ковзне середнє збільшується негайно, якщо фактичне використання перевищує оцінку, так що в ньому певною мірою накопичується пікове використання, а не середнє. Значення min_wal_size обмежує знизу кількість WAL-файлів, які будуть перероблені для майбутнього використання; такий обсяг WAL завжди перероблятиметься, навіть якщо система простоює і оцінка використання говорить, що потрібен зовсім невеликий WAL.
Незалежно від max_wal_size, у кількості wal_keep_segments + 1 останні файли WAL зберігаються в будь-якому випадку. Крім того, якщо використовується архівація WAL, старі сегменти не можуть бути видалені або перероблені, доки вони не будуть заархівовані. Якщо WAL архівується повільніше, ніж генерується, або якщо команда archive_command постійно дає збої, старі WAL файли будуть накопичуватися в pg_xlog, поки ситуація не буде вирішена. Повідомлений сервер, що повільно працює або відмовив, використовує слот реплікації, дасть той же ефект
У режимі відновлення архіву або гарячого резерву сервер періодично виконує точки перезапуску, які схожі на контрольні точки у звичайному режимі роботи: сервер примусово скидає свій стан на диск, оновлює файл pg_control, щоб показати, що вже оброблені дані WAL не потрібно сканувати знову, а потім переробляє всі старі файли сегментів журналу каталогу pg_xlog. Точки перезапуску не можуть виконуватися частіше, ніж контрольні точки на головному сервері, оскільки вони можуть відбуватися лише у записах контрольних точок. Точка перезапуску здійснюється, коли досягається запис контрольної точки і після попередньої точки перезапуску пройшло не менше checkpoint_timeout секунд або розмір WAL може перевищити max_wal_size. Однак через те, що на час виконання точок перезапуску накладаються обмеження, max_wal_size часто перевищується при відновленні, аж до об'єму WAL, що записується в циклі між контрольними точками. (Значення max_wal_size ніколи і не було жорсткою межею, тому завжди слід залишати пристойний запас зверху, щоб не залишитися без вільного місця на диску.)

Найчастіше використовуються дві пов'язані з WAL внутрішні функції: XLogInsertRecord і XLogFlush. XLogInsertRecord застосовується для додавання запису в буфери WAL в пам'яті, що розділяється. Якщо місця для нового запису недостатньо, XLogInsertRecord доведеться записати кілька заповнених буферів WAL (перемістити в кеш ядра). Це небажано, так як XLogInsertRecord використовується при кожній зміні в базі даних на низькому рівні (наприклад, при додаванні рядка) в момент, коли встановлено виняткове блокування сторінок даних, тому дана операція повинна бути максимально швидкою. Що ще гірше, запис буферів WAL може також спричинити створення нового сегменту журналу, що займе ще більше часу. Зазвичай буфери WAL повинні записуватись та зберігатися на диску у функції XLogFlush, яка викликається, здебільшого, при фіксуванні транзакції, щоб результати транзакції збереглися у надійному сховищі. У системах з інтенсивним записом журналу виклики XLogFlush можуть мати місце не так часто, щоб XLogInsertRecord не доводилося робити запис. У таких системах слід збільшити кількість буферів WAL, змінивши параметр wal_buffers. Коли включено режим full_page_writes і система дуже завантажена, збільшення wal_buffers допоможе згладити стрибки в часі відповіді в період відразу після кожної контрольної точки.

Параметр commit_delay визначає, наскільки мікросекунд буде засипати провідний процес групи, що записує в журнал після отримання блокування в XLogFlush, поки підлеглі формують чергу на запис. Під час цієї затримки інші серверні процеси зможуть додавати записи WAL буфери журналу, щоб усі ці записи збереглися на диск в результаті однієї операції синхронізації, яку виконає ведучий. Провідний процес не засинає, якщо вимкнено режим fsync, або кількість сеансів з активними транзакціями менша за commit_siblings, оскільки малоймовірно, що будь-який інший сеанс зафіксує транзакцію найближчим часом. Зауважте, що на деяких платформах, роздільна здатність цього таймера сну становить 10 мілісекунд, так що будь-яке значення параметра commit_delay від 1 до 10000 мікросекунд буде діяти однаково. Крім того, у деяких системах стан сну може тривати трохи довше, ніж вимагає параметр.
Так як мета commit_delay полягає в тому, щоб дозволити вартості кожної операції синхронізації амортизуватися через паралельну фіксацію транзакцій (потенційно за рахунок затримки транзакції), необхідно визначити кількість вартості, перш ніж врегулювання зможе бути вибрано розумно. Чим вище вартість, тим ефективніший буде commit_delay у збільшенні пропускної спроможності транзакцій певною мірою. Програма pg_test_fsync може бути використана, щоб виміряти середній час у мікросекундах, який займає одиночна робота скидання WAL на диск. Значення половини середнього часу, що повідомляється програмою, рекомендується як відправна точка для використання значення в параметрі commit_delay при оптимізації для конкретного обсягу роботи, і говорить про те, скільки потрібно часу для синхронізації скидання єдиної операції запису 8 Кбайт. 

Налаштування параметра commit_delay особливо корисне у разі зберігання WAL у сховищі з високошвидкісними дисками, такими як твердотільні накопичувачі (SSD) або RAID-масиви з кешем запису та аварійним живленням на батареї; але це безперечно повинно тестуватися на репрезентативному робочому навантаженні. Вищі значення commit_siblings повинні використовуватися в таких випадках, тоді як менші значення commit_siblings часто корисні на носіях з більшими затримками. Зверніть увагу, що збільшення значення параметра commit_delay може збільшити затримку транзакції настільки, що постраждає загальна продуктивність транзакцій.

Навіть якщо commit_delay дорівнює нулю (значення за замовчуванням), групова фіксація все одно може статися, але група складатиметься тільки з тих сеансів, яким знадобилося скинути записи про фіксацію на диск за той час, поки відбувалося попереднє скидання. Чим більше сеансів, тим частіше це відбувається навіть при нульовому commit_delay, тому збільшення цього параметра може не надати помітної дії. Установка commit_delay має сенс у двох випадках: (1) коли кілька транзакцій одночасно фіксують зміни, (2) або коли частота фіксацій обмежена пропускною здатністю дискової підсистеми. Однак при затримці через низьку швидкість обертання диска, це налаштування може виявитися корисним навіть при двох сеансах.

Параметр wal_sync_method визначає, як Postgres Pro звертатиметься до ядра, щоб примусово зберегти WAL на диск. Всі методи повинні бути однаковими в плані надійності, за винятком fsync_writethrough, який може іноді примусово скидати кеш диска, навіть якщо інші методи цього не роблять. Однак який із них найшвидший, багато в чому визначається платформою; Ви можете протестувати швидкість, використовуючи модуль pg_test_fsync. Зверніть увагу, що цей параметр не має значення, якщо fsync вимкнено.
Увімкнення параметра конфігурації wal_debug (надається, якщо Postgres Pro було скомпільовано з його підтримкою) призведе до того, що всі виклики пов'язаних з WAL функцій XLogInsertRecord і XLogFlush будуть протоколюватися в журналі сервера. У майбутньому цей параметр може бути замінений більш загальним механізмом.
[джерело](https://postgrespro.ru/docs/postgrespro/9.6/wal-configuration)

## Встановлює розмір WAL, який запускає контрольну точку
Максимальний розмір для збільшення WAL під час автоматичних контрольних точок. Це м’яке обмеження; Розмір WAL може перевищувати max_wal_size за особливих обставин, таких як велике навантаження, помилка archive_command або archive_library або велике значення wal_keep_size. Якщо це значення вказано без одиниць, воно приймається в мегабайтах. За замовчуванням 1 Гб. Збільшення цього параметра може збільшити кількість часу, необхідного для відновлення після збою. Цей параметр можна встановити лише у файлі postgresql.conf або в командному рядку сервера.
РЕКОМЕНДАЦІЇ: за винятком баз даних, які записують більше 1 ГБ/годину даних, у цьому випадку збільште розмір журналу, щоб він містив принаймні годину журналів
[посилання](https://postgresqlco.nf/doc/en/param/max_wal_size/)
